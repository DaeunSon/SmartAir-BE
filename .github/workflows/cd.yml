name: CD for main

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy from'
        required: true
        default: 'develop'

env:
  # DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }} # ECR 사용으로 주석 처리 또는 삭제
  # DOCKERHUB_REPOSITORY_NAME: ${{ secrets.DOCKERHUB_REPOSITORY_NAME }} # ECR 사용으로 주석 처리 또는 삭제
  IMAGE_TAG: latest # 이 부분은 generate_tag 단계에서 덮어쓰므로 큰 의미는 없으나 유지
  AWS_REGION: ap-northeast-2 # AWS 리전 설정

jobs:
  build-and-docker-operations:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.generate_tag.outputs.tag }}
      # ECR_REGISTRY_URI는 secrets에서 직접 사용하므로 output으로 넘길 필요 없음
    
    steps:
    - uses: actions/checkout@v2 # GitHub 저장소의 코드를 워크플로우 러너로 가져옵니다.
    
    - name: Set up JDK 17 # Java 개발 환경(JDK 17)을 설정합니다.
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'corretto'
        
    - name: Create resources directory # Spring Boot 설정 파일이 위치할 디렉토리를 생성합니다.
      run: mkdir -p src/main/resources
        
    - name: Update application.yml # GitHub Secret에 저장된 application.yml 파일 내용을 실제 파일로 생성합니다.
      run: |
        echo "${{ secrets.APPLICATION }}" > ./src/main/resources/application.yml
        
    - name: Set up Gradle # Gradle 빌드 환경을 설정합니다.
      uses: gradle/actions/setup-gradle@v4
      
    - name: Set up Docker # Docker 빌드 환경(Buildx)을 설정합니다.
      uses: docker/setup-buildx-action@v2
        
    - name: Grant execute permission for gradlew # gradlew 파일에 실행 권한을 부여합니다.
      run: chmod +x gradlew
      
    - name: Build JAR # Gradle을 사용하여 Spring Boot 애플리케이션을 JAR 파일로 빌드합니다.
      run: ./gradlew bootjar
      
    - name: Generate Unique Tag # Git commit 해시의 앞 7자리를 사용하여 Docker 이미지 태그를 생성합니다.
      id: generate_tag
      run: echo "::set-output name=tag::$(echo $GITHUB_SHA | cut -c1-7)"
      
    - name: Configure AWS credentials for ECR # AWS 서비스(ECR)에 접근하기 위한 자격 증명을 설정합니다.
      uses: aws-actions/configure-aws-credentials@v1 
      with:
        aws-access-key-id: ${{ secrets.ECR_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.ECR_AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR # 설정된 자격 증명을 사용하여 Amazon ECR에 로그인합니다.
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build Docker image for ECR # Dockerfile을 사용하여 ECR에 푸시할 이미지를 빌드합니다. 이미지 이름은 ECR_REGISTRY_URI와 생성된 태그를 사용합니다.
      run: |
        docker build --platform linux/amd64 -t ${{ secrets.ECR_REGISTRY_URI }}:${{ steps.generate_tag.outputs.tag }} -f docker/Dockerfile .
      
    - name: Push Docker image to ECR # 빌드된 Docker 이미지를 Amazon ECR로 푸시합니다.
      run: |
        docker push ${{ secrets.ECR_REGISTRY_URI }}:${{ steps.generate_tag.outputs.tag }}
        
    # EC2로의 SSH 터널링은 CD 단계에서는 직접적인 DB 접근이 필요 없으므로 제거하거나, 특별한 이유가 있다면 유지합니다.
    # 여기서는 우선 제거된 상태로 가정합니다. CI에서는 테스트를 위해 필요했지만, CD는 빌드/푸시 후 EC2에서 직접 DB를 바라봅니다.
    # - name: Set up SSH key 
    # ...
    # - name: Add EC2 to known hosts
    # ...
    # - name: Start SSH Tunnel
    # ...

  deploy:
    needs: build-and-docker-operations # 'build-and-docker-operations' 작업이 성공해야 실행됩니다.
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code # deploy 작업에서도 코드가 필요할 수 있으므로 checkout (docker-compose.yml 등)
        uses: actions/checkout@v3

      - name: Copy Docker files to EC2 # EC2 인스턴스에 docker-compose.yml과 관련 스크립트를 복사합니다.
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: "ec2-user"
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }} # EC2 접속용 SSH 키 
          port: 22
          source: "docker/docker-compose.yml" # 복사할 파일 목록 (docker-install.sh 제거)
          target: 'compose' # EC2 내 대상 디렉토리
          rm: true # 복사 전 대상 디렉토리 내용 삭제

      - name: SSH remote and Run Docker Compose # EC2에 SSH로 접속하여 Docker Compose 명령을 실행합니다.
        uses: appleboy/ssh-action@master
        env: # EC2에서 실행될 스크립트에 전달할 환경 변수들
          MYSQL_DB_NAME: ${{ secrets.MYSQL_DB_NAME }}       
          MYSQL_DB_USERNAME: ${{ secrets.MYSQL_DB_USERNAME }}  
          MYSQL_DB_PASSWORD: ${{ secrets.MYSQL_DB_PASSWORD }} 
          IMAGE_TAG: ${{ needs.build-and-docker-operations.outputs.image_tag }} # 이전 작업에서 생성된 이미지 태그
          ECR_REGISTRY_URI: ${{ secrets.ECR_REGISTRY_URI }} # ECR 리포지토리 전체 URI
          AWS_REGION: ${{ env.AWS_REGION }} # EC2에서 AWS CLI 사용 위해 전달
          RDS_ENDPOINT: ${{ secrets.RDS_ENDPOINT }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: "ec2-user"
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }} 
          port: 22
          envs: MYSQL_DB_NAME,MYSQL_DB_USERNAME,MYSQL_DB_PASSWORD,IMAGE_TAG,ECR_REGISTRY_URI,AWS_REGION,RDS_ENDPOINT # 스크립트에 전달할 환경변수 목록
          script: |
            cd ~/compose/docker/ 
            
            # EC2 인스턴스에서 ECR에 로그인 (AWS CLI 필요)
            # aws-cli가 설치되어 있다고 가정합니다. Amazon Linux 2에는 기본 설치되어 있습니다.
            # ECR_REGISTRY_URI에서 레지스트리 ID(AWS 계정 ID) 추출
            ECR_ACCOUNT_ID=$(echo $ECR_REGISTRY_URI | cut -d'.' -f1)
            aws ecr get-login-password --region $AWS_REGION | sudo docker login --username AWS --password-stdin $ECR_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

            # .env 파일 생성 또는 업데이트
            sudo touch .env
            sudo echo "
            MYSQL_DB_NAME=$MYSQL_DB_NAME
            MYSQL_DB_USERNAME=$MYSQL_DB_USERNAME
            MYSQL_DB_PASSWORD=$MYSQL_DB_PASSWORD
            IMAGE_TAG=$IMAGE_TAG
            RDS_ENDPOINT=$RDS_ENDPOINT
            ECR_REGISTRY_URI=$ECR_REGISTRY_URI 
            AWS_REGION=$AWS_REGION" | sudo tee .env # docker-compose.yml에서 참조할 환경변수들
            
            # Docker 설치 스크립트 실행 (필요한 경우) - 주석 처리
            # sh ./scripts/docker-install.sh 

            # 최신 이미지 pull
            sudo docker pull $ECR_REGISTRY_URI:$IMAGE_TAG 
            
            # Docker Compose로 애플리케이션 재시작
            sudo docker-compose down  
            sudo docker-compose up -d   